.SUFFIXES:
#---------------------------------------------------------------------------
# = Dissecting a WUT compatible make file =
# We ultimately want to port code onto the WIIU.  This is a dumbed down makefile
# so we can understand the imported rules and expected naming conventions
# Don't actually use this for your own makefile.
#
# Porting projects with existing build configs is challenging. Existing projects have
#  * multiple sources files with main() in the same directory
#  * autogenerated build rules, autotools
#  * expected variable naming conventions
#  * expected directory layouts
#
# usage:  make -f "thisfile.mk" (clean|V=1)

ifeq ($(strip $(DEVKITPRO)),)
$(error "Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>/devkitpro")
endif

TOPDIR ?= $(CURDIR)

$(info #------------------------------------------------------------------------)
#-------------------------------------------------------------------------------
# Notice the imported variables
#-------------------------------------------------------------------------------
include $(DEVKITPRO)/wut/share/wut_rules
$(info # ---- initial wut_root compiller variable values   ----)
$(info included CC		= $(CC))
$(info included CFLAGS		= $(CFLAGS))
$(info # ---- initial wut_root linker variable values   ----)
$(info included LD		= $(LD))
$(info included LDFLAGS		= $(LDFLAGS))
$(info included AR		= $(AR))
$(info # ---- initial wut_root  variable values   ----)
$(info included WUT_ROOT		= $(WUT_ROOT))
$(info included PORTLIBS		= $(PORTLIBS))
$(info included PORTLIBS_PATH	= $(PORTLIBS_PATH))
$(info included ARCH			= $(ARCH))
$(info included MACHDEP		= $(MACHDEP))
$(info included RPXSPECS		= $(RPXSPECS))

export LD	:=	$(CC)
#-------------------------------------------------------------------------------
# Constraints for your Makefile due to wut_rules
#-------------------------------------------------------------------------------
# import brings in this rule for the TARGET
# %.elf:
#	@echo linking ... $(notdir $@)
#	$(ADD_COMPILE_COMMAND) end
#	$(SILENTCMD)$(LD) $(LDFLAGS) $(OFILES) $(LIBPATHS) $(LIBS) -o $@ $(ERROR_FILTER)
#	$(SILENTCMD)$(NM) -CSn $@ > $(notdir $*.lst) $(ERROR_FILTER)
#
# instead of a freeform Makefile, you MUST adhere to the following
#   OFILES (not "OBJECTS")   .o file list
#   LIBS                     -lwut  or `pkg-config --libs-only-l sdl2`
#   LIBPATHS                 -L$(DEVKITPRO)/wut/lib
#                              or  `pkg-config --libs-only-L sdl2`
#   LIBDIRS   (optional)     directories above a /lib subdir, but YOU must concatenate
#   ex.   export LIBPATHS	:=	$(foreach dir,$(LIBDIRS),-L$(dir)/lib)
#
#
#  Additionally, do not redefine this
# %.o: %.c
#	$(SILENTMSG) $(notdir $<)
#	$(ADD_COMPILE_COMMAND) add $(CC) "$(CPPFLAGS) $(CFLAGS) -c $< -o $@" $<
#	$(SILENTCMD)$(CC) -MMD -MP -MF $(DEPSDIR)/$*.d $(CPPFLAGS) $(CFLAGS) -c $< -o $@ $(ERROR_FILTER)
#
#   notice:  "$(CC) -MMD -MP ... $(DEPSDIR)/$*.d"
#     recall that .o are rebuilt when .c source files change, but not when .h headers change.  
#     .d files give us insurance, such that when headers change, Make knows to recompile.
#     Since we chose this feature, we must define a rule
#        DEPENDS	:=	$(OFILES:.o=.d)
#     then add this at the end.
#       -include $(DEPENDS)
#
#  Alternatively, you could reimplement the logic in wut_rules, 
#  but future improvements to WUT could leave your code behind
#-------------------------------------------------------------------------------



# Explicit Source file example
#  Say we have multiple CLIs sources in one folder, each with a main()
#  We can't just include *.c, compile and link them. Rather we need to specify
#  a single main() and its dependencies, (or build deps a as library to link in)
SOURCES := sdlmain.c sdltriangle.c sdlanimate.c

# Compiler flags
#CFLAGS = -Wall -g 
CFLAGS	:=	-O3 -ffunction-sections -fdata-sections \
			$(MACHDEP) \
			-D_ISOC11_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -U__STRICT_ANSI__ \
			-D_XOPEN_SOURCE=600 \
			-fomit-frame-pointer \
			-ffast-math -fno-math-errno  -funsafe-math-optimizations -ffinite-math-only -fno-trapping-math \
			-O3 -Ofast -std=c11 -mcpu=750 -meabi -mhard-float

CFLAGS	+=	$(INCLUDE) -I$(WUT_ROOT)/include \
				-D__WIIU__ -D__WUT__ -DBIGENDIAN -DUSE_MBEDTLS

CXXFLAGS	:= $(CFLAGS)

ASFLAGS	:=	$(ARCH)
#LDFLAGS	=	$(ARCH) $(RPXSPECS) -Wl,-Map,$(notdir $*.map)
#-----------------------------------------------------------------------------
# a linker flag generate a detailed map of the program's memory layout after linking 
#-----------------------------------------------------------------------------
LDFLAGS	=	$(ARCH) $(RPXSPECS) -Wl,-Map,$(TARGET).map

LIBPATHS	:=  -L$(WUT_ROOT)/lib
LIBS	:=	-lwut

#-------------------------------------------------------------------------------
# portlibs and 3rd party packages
#   notice how you can include multiple PKG_CONFIG_PATH's.  There are at 
#   least 2 paths (ppc and wiiu).  With porting you may end up adding your own.
#-------------------------------------------------------------------------------
# Linker flags
PKG_CONFIG_PATH = $(DEVKITPRO)/portlibs/ppc/lib/pkgconfig:$(DEVKITPRO)/portlibs/wiiu/lib/pkgconfig
export PKG_CONFIG_PATH
PKGCONF_WIIU	:= /usr/bin/pkg-config
SDL_CFLAGS		=	$(shell $(PKGCONF_WIIU) --cflags SDL2_image SDL2_ttf sdl2)
SDL_CXXFLAGS	+=	$(shell $(PKGCONF_WIIU) --cflags SDL2_image SDL2_ttf sdl2)
SDL_LIBPATHS	+=	$(shell $(PKGCONF_WIIU) --libs-only-L SDL2_image SDL2_ttf sdl2) \
				$(shell $(PKGCONF_WIIU) --libs-only-L harfbuzz freetype2)	
SDL_LIBS		+=	$(shell $(PKGCONF_WIIU) --libs-only-l SDL2_image SDL2_ttf sdl2) \
				$(shell $(PKGCONF_WIIU) --libs-only-l harfbuzz freetype2)


#-------------------------------------------------------------------------------
# romfs
#    all fonts, images and such go into the ROMFS subfolder and are 
#    packaged with your homebrew app.
# notice OFILES : be sure to "+=" or just include this in further
#    references to the typical makefile OBJECTS variable
#-------------------------------------------------------------------------------
ROMFS		:= ./romfs
include $(PORTLIBS_PATH)/wiiu/share/romfs-wiiu.mk
CFLAGS		+=	$(ROMFS_CFLAGS)
CXXFLAGS	+=	$(ROMFS_CFLAGS)
LIBS		+=	$(ROMFS_LIBS)
OFILES		+=	$(ROMFS_TARGET)

#-------------------------------------------------------------------------------
#  Rename / merge variables to be compliant with build rules
#-------------------------------------------------------------------------------
OFILES += $(SOURCES:.c=.o)
OUTPUT	= $(TARGET)

# Remember, the included %.elf rule contains "-MMD -MP $*.d" to track header changes.
# Let's make sure the DEPENDS files exist.
DEPSDIR	= .
DEPENDS	:=	$(OFILES:.o=.d)
$(info DEPENDS $(DEPENDS))

.PHONY: $(BUILD) clean all 

#-------------------------------------------------------------------------------
# Final values, as needed by 
#	$(SILENTCMD)$(LD) $(LDFLAGS) $(OFILES) $(LIBPATHS) $(LIBS) -o $@ $(ERROR_FILTER)
#	$(SILENTCMD)$(NM) -CSn $@ > $(notdir $*.lst) $(ERROR_FILTER)
#-------------------------------------------------------------------------------
$(info # ---- final compiller variable values   ----)
$(info final CC		= $(CC))
$(info final CFLAGS		= $(CFLAGS))
$(info # ---- final linker variable values   ----)
$(info final LD		= $(LD))
$(info final LDFLAGS	= $(LDFLAGS))
$(info final OFILES		= $(OFILES))
$(info final LIBPATHS	= $(LIBPATHS))
$(info final LIBS		= $(LIBS))


#-------------------------------------------------------------------------------
#  Homebrew executable build rules
#-------------------------------------------------------------------------------
# Remember, we already have at least two imported rules you must leave alone
# %.elf:
#   and 
# %.o: %.c
#-------------------------------------------------------------------------------

all: $(OUTPUT).wuhb

$(OUTPUT).wuhb	:	$(OUTPUT).rpx
$(OUTPUT).rpx	:	$(OUTPUT).elf
$(OUTPUT).elf	:	$(OFILES)

# Again, because the included %.elf rule contains "-MMD -MP $*.d" to track header changes.
-include $(DEPENDS)

# Clean rule: Remove the executables and build artifacts
clean:
	rm -f $(TARGET).rpx $(TARGET).elf $(TARGET).wuhb  $(TARGET).map $(TARGET).lst
	rm -f $(OFILES) $(DEPENDS)
